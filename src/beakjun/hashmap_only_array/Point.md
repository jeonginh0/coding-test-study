# 🔍 접근 방법
이 문제는 내장 라이브러리를 사용하지 않고, 기본적인 해시맵을 직접 구현하는 문제입니다.

## ✅ 핵심 포인트:
• 키(key)를 해시 함수로 변환해 저장 위치를 결정
• 같은 버킷에 여러 요소가 있을 경우(충돌 시)에는 연결 리스트로 해결
• 기본 연산 put, get, remove 구현

---

## 🚀 접근 방식
1. 고정 크기 배열을 버킷 배열로 선언
2. 각 버킷은 연결 리스트 형태로 키-값 쌍을 저장
3. put: 키 해시값에 맞는 버킷(위에서 말한 저장 위치 )에 탐색 후 있으면 값 업데이트, 없으면 새 노드 추가
4. get: 해당 버킷에서 키 탐색 후 값 반환, 없으면 -1 반환
5. remove: 해당 버킷에서 키 탐색 후 노드 제거

> ⚠️ **주의사항**
- 해시 함수는 키를 버킷 개수로 나눈 나머지 사용
- 연결 리스트 직접 구현 또는 Node 클래스를 활용
- 성능 개선을 위해 리사이징은 생략 가능 (문제에서 주어진 조건)

---

## 📝 코드 설명
- SIZE 는 버킷 개수→ 배열로 버킷 관리
- 각 버킷은 연결 리스트로 충돌 해결
- put → 연결 리스트 탐색 후 키가 이미 존재하면 값 수정, 없으면 끝에 추가
- get → 키가 있으면 값 반환, 없으면 - 1 출력
- remove → 연결 리스트에서 키에 해당하는 노드 찾아 연결 해결

---

## 📊 복잡도 분석

- 시간 복잡도 
  - 평균 O(1) (충돌 적을 경우) 최악
  - 0(n) (모든 키가 같은 버킷에 몰릴 때)
- 공간 복잡도: 0(n) (저장된 키 - 값 수에 비례)

---

## ⚡ 최적화 팁

1. [필요한 자료구조 인식] : 연결 리스트 대신 트리 구조로도 가능은 함
2. [문제 조건 필수적으로 확인] : 리사이징을 하면 성능 개선이 가능하나 문제에서 요구하지 않아서 할 필요는 없음

---

## 🎯 학습 포인트

- 해시맵의 기본 구조와 충돌 해결 방법 이해
- 연결 리스트를 직접 구현하여 데이터 구조 응용
- 해시 함수 설계와 버킷 인덱스 계산 방법 습득

---

## 🔗 관련 문제

- 해시맵을 구현 할땐 충돌을 꼭 염두에 둘것
- 키의 범위와 충돌 가능성을 판단하여 적합한 버킷 크기 설정
