# 🔍 접근 방법

이 문제는 DP(동적 계획법)를 활용하는 문제입니다.

## ✅ 핵심 포인트

- 문제는 'Each time you can either climb 1 or 2 steps'(한번에 계단을 1칸 또는 2칸씩 오를 수 있다)는 조건
- n번째 계단에 도달하는 방법은 `(n-1) + (n-2)` 계단에서 오는 방법의 합
- 이는 `피보나치 수열`과 동일한 구조

---

## 🚀 접근 방식

1. 점화식: dp[n] = dp[n-1] + dp[n-2] 를 세운다
2. 초기값 설정: dp[1] = 1, dp[2] = 2
3. Bottom-up 방식으로 dp[n]까지 채운다

> ⚠️ **주의사항**
- n == 1 또는 2일 때 예외 처리 필요
- 공간 최적화를 통해 O(1) 공간으로 줄일 수 있음

---

## 📝 코드 설명

- `dp[i] = dp[i-1] + dp[i-1]` 의 점화식을 변형 → `공간 복잡도 O(1)`으로
- 두 가지 ( one step before, two step before) 로 나누어서 순차 계산
- 공간 복잡도는 최적화 되었으나, 특정 경로를 추적해야 하는 상황이면 불가능

---

## 📊 복잡도 분석

- 시간 복잡도: `0(N)`
- 공간 복잡도: `0(1)`

---

## ⚡ 최적화 팁

1. [점화식 도출] : 이 문제의 경우 피보나치와 동일한 점화식을 사용.
2. [배열 대신 변수 ] : 현재 코드 최적화의 핵심. dp 배열을 쓰지 않고 두 개 변수로 메모리 절약

---

## 🎯 학습 포인트

- 점화식 도출 ( 현 문제의 경우 피보나치 수열 )
- 동적 계획법 중 Bottom-up 방식
- 공간 최적화 ( 점화식 배열 → 변수활용)

---

## 🔗 관련 문제

- 점화식이라고 무조건 배열에 저장할 필요는 없음
- DP 를 풀 때는 공간 최적화 가능 여부를 항상 점검 !

