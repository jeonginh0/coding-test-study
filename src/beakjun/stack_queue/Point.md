# 🔍 접근 방법

이 문제는 두 개의 **스택(stack)** 을 사용하여 **큐(queue)** 의 동작을 구현하는 문제입니다.

## ✅ 핵심 포인트

- **두 개의 스택**을 사용하여 입력(`push`)과 출력(`pop`, `peek`)을 분리
- `push` 시에는 **입력 스택 (`stackIn`)**에만 저장
- `pop`, `peek` 시에는 **출력 스택 (`stackOut`)**에서 꺼냄
- 단, `stackOut`이 비어 있다면 `stackIn`의 모든 요소를 이동시켜야 함 (순서 반전)
- `empty()`는 두 스택이 모두 비었는지로 판단

---

## 🚀 접근 방식

| 연산  | 설명 |
|--------|------|
| `push(x)` | `stackIn`에 그냥 push |
| `pop()`   | `stackOut`이 비었으면 `stackIn`의 모든 요소를 pop해서 `stackOut`에 push한 후, `stackOut.pop()` |
| `peek()`  | `pop()`과 동일한 방식이지만 pop하지 않고 `stackOut.peek()` |
| `empty()` | `stackIn`과 `stackOut` 모두 비어 있는지 확인 |

> ⚠️ **주의사항**
- 오직 **스택의 기본 연산(push, pop, peek, isEmpty)**만 사용해야 함
- 배열 인덱스 접근 등 직접 조작은 불허

---

## 📝 코드 설명

- `stackIn`: 요소를 삽입하는 스택 (`push` 용)
- `stackOut`: 요소를 제거/조회하는 스택 (`pop`, `peek` 용)
- `stackOut`이 비었을 때만 `stackIn`의 내용을 이동시켜 **큐의 FIFO 성질 유지**
- `pop`, `peek`는 항상 `stackOut`에서 처리
- `empty()`는 두 스택이 모두 비었는지를 검사

---

## 📊 복잡도 분석

| 연산      | 시간 복잡도 |
|-----------|-------------|
| `push`    | O(1)        |
| `pop`     | **Amortized O(1)** (최악 O(n)) |
| `peek`    | **Amortized O(1)** (최악 O(n)) |
| `empty`   | O(1)        |

- `pop` 및 `peek`는 **한 번 옮긴 데이터는 다시 옮기지 않으므로**, 전체 n개의 연산에 대해 O(n) → **상당한 평균 효율성 보장**

| 자원      | 공간 복잡도 |
|-----------|-------------|
| 전체 저장 | O(n) (스택 두 개에 중복 저장 가능) |

---

## ⚡ 최적화 팁

1. **불필요한 이동을 최소화**
    - `stackOut`이 비었을 때만 `stackIn`에서 이동
2. **스택 연산만 사용**
    - 문제 조건 위배 방지
3. **기본 API 적극 활용**
    - `push`, `pop`, `peek`, `isEmpty` 등은 내부적으로 최적화되어 있음

---

## 🎯 학습 포인트

- 스택을 이용한 **큐 시뮬레이션** 방식 익히기
- **스택 vs 큐**의 구조 및 작동 방식 비교
- **상각 시간 복잡도(Amortized Time Complexity)** 개념 이해

---

## 🔗 관련 문제

- **큐를 스택으로 구현하기** 또는 그 반대 문제
- 핵심은 **입력 스택과 출력 스택의 분리**
- `pop()`이나 `peek()` 호출 시 **항상 이동하는 것이 아니라**, **필요할 때만 이동**하는 것이 성능을 좌우

